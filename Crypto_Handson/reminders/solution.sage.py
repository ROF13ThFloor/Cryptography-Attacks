

# This file was *autogenerated* from the file solution.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_115 = Integer(115); _sage_const_3 = Integer(3); _sage_const_16 = Integer(16)
from Crypto.PublicKey import RSA
from Crypto.Util.number import * 
from Crypto.PublicKey.RSA import *
from Crypto.Cipher import *
import binascii
import os
import itertools
import unicodedata
import rsa


def find_common_key(all_N):
    pubkeys = all_N
    q = _sage_const_0 
    for p1, p2 in itertools.permutations(pubkeys, int(_sage_const_2 )):
        g = gcd(p1, p2)
        if g != _sage_const_1 :
            print("theese modules have common factor ",pubkeys.index(p1),pubkeys.index(p2))
            print("we have common factor with gcd ")
            print("modules is : ", pubkeys.index(p1), "   :" , p1)
            index_of_pubkey = pubkeys.index(p1)
            Q_factor = p1 / g 
            return g , Q_factor , index_of_pubkey
           #return p and Q_factor





count = _sage_const_1 
all_N = list()
for i in range(_sage_const_0 ,_sage_const_115 ):
    p_key = RSA.importKey(open('pkeys/pubkey_' + str(i).zfill(_sage_const_3 ) + '.pem','r').read())
    all_N.append(p_key.n)
    count = count + _sage_const_1  


print('Step 1: Find common factor key .. . . ')    

attack_point = find_common_key(all_N)

e_factor = RSA.importKey(open('pkeys/pubkey_'+ str(attack_point[_sage_const_2 ]).zfill(_sage_const_3 ) + '.pem','r').read()).e 
Modules_factor = RSA.importKey(open('pkeys/pubkey_'+ str(attack_point[_sage_const_2 ]).zfill(_sage_const_3 ) + '.pem','r').read()).n

euler_num = (attack_point[_sage_const_0 ] - _sage_const_1 ) * (attack_point[_sage_const_1 ] - _sage_const_1 )

d_fctor = inverse_mod(e_factor , euler_num)


with open('encs/secret_' + str(attack_point[_sage_const_2 ]).zfill(_sage_const_3 ) + '.enc' ,"rb" ) as file:
    enc_data = file.read()



print("encrypted msg in byte is " , enc_data)
print("encrypted msg in hex is :" ,enc_data.hex())
print("integer of cipher is " , int.from_bytes(enc_data, "big"))

print("p is : " , attack_point[_sage_const_0 ])
print("q is : " , attack_point[_sage_const_1 ])
print("modules is : " , Modules_factor)
print("multiple p * q is  : " , attack_point[_sage_const_0 ]*attack_point[_sage_const_1 ])
print("euler_num is : " , euler_num)
print("e is : " ,  e_factor)
print("d is : " , d_fctor)
print("e*d = " , mod(d_fctor*e_factor , euler_num))
plaintext = power_mod(int(enc_data.hex() , _sage_const_16 ) , d_fctor, Modules_factor)
p = binascii.unhexlify(hex(plaintext)[_sage_const_2 :])
print(p)

#print("d is " , d_fctor)

#print(" module is : " , Modules_factor)









#print(int_to_msg(plaintext))
#pretty_print(binascii.unhexlify(hex(plaintext)[2:]))








